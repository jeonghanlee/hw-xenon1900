#
#  Honeywell Xenon 1900 Barcode scanner
#
# macros required:
#
#  HWUNIT              : dev asyn channel name
#  SYSDEV              : Quite generic single name component
# 
#  author : Jeong Han Lee
#  email  : jeonghan.lee@gmail.com
#  Date   : 
#  version : 0.0.1
#
#------------------------------------------------------------------------------
# # CLOCK
# # 
# #
# record(stringin, "$(SYSDEV)Clock")
# {
#     field(DESC, "The internal clock time")
#     field(DTYP, "stream")
#     field( INP, "@mps8500.proto getVal(CLOCK,s) $(HWUNIT)")
#     field(SCAN, "1 second")
# }

# #------------------------------------------------------------------------------
# # ID (P20)
# #
# #
# record(stringin, "$(SYSDEV)ID-Sts1")
# {
#     field(DESC, "User Setable IDs")
#     field(DTYP, "stream")
#     field( INP, "@mps8500.proto getId($(SYSDEV)ID-Sts2,$(SYSDEV)ID-Sts3,$(SYSDEV)ID-Sts4)  $(HWUNIT)")
#     field(FLNK, "$(SYSDEV)VER-Sts1")
#     field(PINI, "YES")
# }

# record(stringin, "$(SYSDEV)ID-Sts2")
# {
#     field(DESC, "User Setable IDs")
#     field(DTYP, "Soft Channel")
# }

# record(stringin, "$(SYSDEV)ID-Sts3")
# {
#     field(DESC, "User Setable IDs")
#     field(DTYP, "Soft Channel")
# }

# record(stringin, "$(SYSDEV)ID-Sts4")
# {
#     field(DESC, "User Setable IDs")
#     field(DTYP, "Soft Channel")
# }

# #------------------------------------------------------------------------------
# # VER (P49)
# #
# #
# record(stringin, "$(SYSDEV)VER-Sts1")
# {
#     field(DESC, "Program and its version")
#     field(DTYP, "stream")
#     field( INP, "@mps8500.proto getVer($(SYSDEV)VER-Sts2,$(SYSDEV)VER-Sts3)  $(HWUNIT)")
#     field(FLNK, "$(SYSDEV)PRINT-Sts1")
# }

# record(stringin, "$(SYSDEV)VER-Sts2")
# {
#     field(DESC, "Program and its version")
#     field(DTYP, "Soft Channel")
# }

# record(stringin, "$(SYSDEV)VER-Sts3")
# {
#     field(DESC, "Program and its version")
#     field(DTYP, "Soft Channel")
# }

# #------------------------------------------------------------------------------
# # PRINT (P27)
# # 
# #
# record(stringin, "$(SYSDEV)PRINT-Sts1")
# {
#     field(DESC, "SYSTEM Type and its version")
#     field(DTYP, "stream")
#     field( INP, "@mps8500.proto getPrint($(SYSDEV)PRINT_Sts2) $(HWUNIT)")
# }

# record(stringin, "$(SYSDEV)PRINT_Sts2")
# {
#     field(DESC, "SYSTEM Type and its version")
#     field(DTYP, "Soft Channel")
# }

# #------------------------------------------------------------------------------
# #
# # LOC : switch the line-in-command to the local line
# # REM : switch the line-in-command to the remote line
# #
# # CMD and CMDSTATE have the different outputs, the first attempt to use CMD
# # instead of CMDSTATE. However, in case we have to use CMDSTATE, select
# # MBBO/MBBI other than BO/BI
# #
# #------------------------------------------------------------------------------
# record(mbbo, "$(SYSDEV)RMT_CMD")
# {
#     field(DESC, "Remote Interface Mode")
#     field(DTYP, "stream")
#     field( OUT, "@mps8500.proto setRemoteMode($(SYSDEV)RMT_STS) $(HWUNIT)")
#     field(ZRST, "Local")
#     field(ZRVL, "0")
#     field(ONST, "Remote")
#     field(ONVL, "1")
#     field(TWST, "INVALID")
#     field(THSV, "INVALID")
#     field(FRSV, "INVALID")
#     field(FVSV, "INVALID")
#     field(SXSV, "INVALID")
#     field(SVSV, "INVALID")
#     field(EISV, "INVALID")
#     field(NISV, "INVALID")
#     field(TESV, "INVALID")
#     field(ELSV, "INVALID")
#     field(TVSV, "INVALID")
#     field(TTSV, "INVALID")
#     field(FTSV, "INVALID")
#     field(FFSV, "INVALID")
#     # unknown state severity
#     field(UNSV, "INVALID")
#     field(IVOA, "Don't drive outputs")
#     field(FLNK, "$(SYSDEV)RMT_RSTS")
# }

# # CMD
# #      REM
# #      LOC
# #      error message
# # 
# # CMDSTATE
# #      REMOTE
# #      LOCAL
# #      LOCK
# #      error message
# #
# record(mbbi, "$(SYSDEV)RMT_RSTS")
# {
#     field(DESC, "Remote Interface Mode Status")
#     field(DTYP, "stream")
#     field( INP, "@mps8500.proto getRemoteMode $(HWUNIT)")
#     field(ZRST, "Local")
#     field(ZRVL, "0")
#     field(ONST, "Remote")
#     field(ONVL, "1")
#     field(TWST, "INVALID")
#     field(THSV, "INVALID")
#     field(FRSV, "INVALID")
#     field(FVSV, "INVALID")
#     field(SXSV, "INVALID")
#     field(SVSV, "INVALID")
#     field(EISV, "INVALID")
#     field(NISV, "INVALID")
#     field(TESV, "INVALID")
#     field(ELSV, "INVALID")
#     field(TVSV, "INVALID")
#     field(TTSV, "INVALID")
#     field(FTSV, "INVALID")
#     field(FFSV, "INVALID")
#     # unknown state severity
#     field(UNSV, "INVALID")
#     field(PINI, "YES")
# }

# record(stringout, "$(SYSDEV)RMT_STS")
# {
#     field(DESC, "RMT Answer and Errors Status")
#     field(DTYP, "Soft Channel")
# }

# # ----------------------------------------------------------
# # RLOCK
# # 
# # No way to get RLOCK state, so use the Soft Channel to keep
# # their messages 
# # ----------------------------------------------------------
# record(stringin, "$(SYSDEV)RLOC_CMD")
# {
#     field(DESC, "Lock the line-in command to the remote")
#     field(DTYP, "stream")
#     field( INP, "@mps8500.proto setRemLock($(SYSDEV)RLOC_STS) $(HWUNIT)")
# }

# record(stringout, "$(SYSDEV)RLOC_STS")
# {
#     field(DESC, "RLOCK Answer and Errors Status")
#     field(DTYP, "Soft Channel")
# }

# # ----------------------------------------------------------
# # S1H 
# # Return 24 internal status in HEX
# # 24 bit, so we have to divide two 12 bit records
# # _desc_ mbbi are used to identify its corresponding name only.
# # 
# # bit 0  - 11, Char 24 - 13 : First 12 bits
# # bit 12 - 23, Char 14 -  1 : Second 12 bits
# # See page 31, Programmers Guide MPS 8500 Standard Commands
# #
# # S1-sts_ is passive, so one change any parameter through PVs or others,
# # it should be defined in as FLNK in order to  update S1H in EPICS IOC
# #
# record(longin, "$(SYSDEV)S1-sts_")
# {
#     field(DESC, "Status 1 HEX")
# #    field(SCAN, "0.5 second")
#     field(SCAN, "Passive")
#     field(DTYP, "stream")
#     field( INP, "@mps8500.proto getStatusWord1 $(HWUNIT)")
#     field(PINI, "YES")
# }

# record(calc, "_$(SYSDEV)S1-1sts_")
# {
#     field(DESC, "First 12 Bits of SH1 Return")
#     field(SCAN, "Passive")
#     field(CALC, "(A&0x0000FFF)")
#     field(INPA, "$(SYSDEV)S1-sts_ CPP")
#     field(FLNK, "$(SYSDEV)S1-bit1_sts")
# }

# record(mbbiDirect, "$(SYSDEV)S1-bit1_sts")
# {
#     field(DESC, "Status 1 HEX Set 1")
#     field(SCAN, "Passive")
#     field( INP, "_$(SYSDEV)S1-1sts_.VAL")
# }

# record(mbbi, "$(SYSDEV)S1-bit1_desc")
# {
#     field(ZRST, "Spare")
#     field(ONST, "PS Not Ready")
#     field(TWST, "Magnet Over Temperature")
#     field(THST, "Magnet Waterflow Failure")
#     field(FRST, "Panic Button Door Switch")
#     field(FVST, "PS Over Temperature")
#     field(SXST, "Thermal Breaker Fuses")
#     field(SVST, "Earth Leakage Failure")
#     field(EIST, "PS Waterflow Failure")
#     field(NIST, "Phase Failure")
#     field(TEST, "Preregulator Failure")
#     field(ELST, "Regulation module Failure")
#     field(TVSV, "INVALID")
#     field(TTSV, "INVALID")
#     field(FTSV, "INVALID")
#     field(FFSV, "INVALID")
#     # unknown state severity
#     field(UNSV, "INVALID")
# }

# record(calc, "_$(SYSDEV)S1-2sts_")
# {
#     field(DESC, "Second 12 Bits of SH1 Return")
#     field(SCAN, "Passive")
#     field(CALC, "(A&0xFFF000)>>12")
#     field(INPA, "$(SYSDEV)S1-sts_ CPP")
#     field(FLNK, "$(SYSDEV)S1-bit2_sts")
# }

# record(mbbiDirect, "$(SYSDEV)S1-bit2_sts")
# {
#     field(DESC, "Status 1 HEX Set 2")
#     field(SCAN, "Passive")
#     field( INP, "_$(SYSDEV)S1-2sts_.VAL")
# }

# record(mbbi, "$(SYSDEV)S1-bit2_desc")
# {
#     field(ZRST, "DC Overload")
#     field(ONST, "DC Overcurrent - OCP")
#     field(TWST, "Sum - Interlock")
#     field(THST, "One Transistor Fault")
#     field(FRST, "Spare Interlock")
#     field(FVST, "Unit")
#     field(SXST, "DAC17")
#     field(SVST, "DAC16")
#     field(EIST, "Regulation Transformer")
#     field(NIST, "Polarity Reversed")
#     field(TEST, "Polarity Normal")
#     field(ELST, "Main Power Off")
#     field(TVSV, "INVALID")
#     field(TTSV, "INVALID")
#     field(FTSV, "INVALID")
#     field(FFSV, "INVALID")
#     # unknown state severity
#     field(UNSV, "INVALID")
# }



# # ----------------------------------------------------------
# # F : switch-off the pwer supply (main contact)
# # See page 18, Programmers Guide MPS 8500 Standard Commands
# # N : switch-on the power supply (main contact). 
# # See page 23, Programmers Guide MPS 8500 Standard Commands
# #
# # S1 Statue bit BB (12) : 1 means Power Supply OFF
# #                       : 0 means Power Supply ON

# record(bo, "$(SYSDEV)PowerSwitch_CMD")
# {
#     field(DESC, "Power Suppoly Switch oN/ofF")
#     field(DTYP, "stream")
#     field( OUT, "@mps8500.proto setofFoN $(HWUNIT)")
#     field(ZNAM, "on")
#     field(ONAM, "off")
#     field(FLNK, "$(SYSDEV)S1-sts_")
# }

# record(bi, "$(SYSDEV)PowerSwitch_RSTS")
# {
#     field(DESC, "Readback Power Swtch Status")
#     field( INP, "$(SYSDEV)S1-bit2_sts.BB CPP")
#     field(ZNAM, "on")
#     field(ONAM, "off")
#     field(FLNK, "$(SYSDEV)PowerSwitch_RSTS_")
# }

# #
# # Update PowerSwitch_CMD automatically, based on PowerSwitch_RSTS
# # One will see how it works, after rebooting IOC while HW is
# # running well.
# # Reference : Michael Davidsaver sr725 db

# record(longout, "$(SYSDEV)PowerSwitch_RSTS_")
# {
#     field( DOL, "$(SYSDEV)PowerSwitch_RSTS NPP")
#     field(OMSL, "closed_loop")
#     field( OUT, "$(SYSDEV)PowerSwitch_CMD NPP")
# }


# # ----------------------------------------------------------
# # RS (P30)
# # Reset is used to clear all pending interlocks
# # Unclear definition on what all pending interlocks are
# # according to the  Programmers Guide,
# # No idea how to implement them in a simulator. 



# record(bo, "$(SYSDEV)RST_CMD")
# {
#     field(DESC, "Device Reset cmd")
#     field(DTYP, "stream")
#     field( OUT,  "@mps8500.proto sendCmd(RS) $(HWUNIT)")
#     field(FLNK, "$(SYSDEV)S1-sts_")
# }

# # Page 13/14/15 DAC have 5 channels that have the following meanings
# # Set
# # DA 0,xxx (WA) output_current in ppm
# # DA 1,xxx (W1) Slew rate through 8 bit optional port (added to HW)
# # DA 2,xxx (W2) Optional
# # DA 3,xxx (W3) Slew rate through 8 bit optional port scaled to mA/sec
# # DA 4,xxx      Slew rate through 12 bit serial DAC (From SW version SC5110)
# # ----------------------------------------------------------------------------
# # Get
# # DA 0     (RA) read the currently numerical set value in ppm resolution. 
# #               0 <= DA 0 <= 999999, PO gives its polarity status
# #               DA 0 will deliver the present polarity status automatically. 
# #               Currently DA 0 and PO works indepently with each other in this simulator
# #               
# # DA 1     (R1) Slew rate through 8 bit optional port (added to HW)
# # DA 2     (R2) Optional
# #               0 <= DA {1,2} <= 255 from option port {0,1}.
# #               The optional port 0 is normally used for the SLEW-DAC port (HW conrolled
# #               slew rate circuit
# #               The optional port 1 is for extension use
# # DA 3     (R3) read an absolute value between 0 and 1550 from option port 0 (SLEW-DAC)
# #               Similar to R1, and this value is interpreted to mA/sec slew rate setting
# #               The scaling can be adjusted via Esc<AD command also
# #               
# # DA 4          Slew rate through 12 bit serial DAC (From SW version SC5110)
# #

# # DA 0
# # Should consider PO and unipolar and bipolar configuration properly later.
# #
# record(ao, "$(SYSDEV)DAC0_SET")
# {
#     field(DESC, "DAC0 Set")
#     field(DTYP, "stream")
#     field( OUT, "@mps8500.proto setDA(0) $(HWUNIT)")
#     field(DRVL, "-999999")
#     field(DRVH, "+999999")
#     field( EGU, "ppm")
#     field(FLNK, "$(SYSDEV)DAC0_RB")
# }

# record(ai, "$(SYSDEV)DAC0_RB")
# {
#     field(DESC, "DAC0 Readback")
#     field(DTYP, "stream")
#     field( INP, "@mps8500.proto getDA(0) $(HWUNIT)")
#     field( EGU, "ppm")
#     field(PINI, "YES")
#     field(FLNK, "$(SYSDEV)DAC0Update-RB_")
# }

# record(longout, "$(SYSDEV)DAC0Update-RB_")
# {
#     field( DOL, "$(SYSDEV)DAC0_RB NPP")
#     field(OMSL, "closed_loop")
#     field( OUT, "$(SYSDEV)DAC0_SET NPP")
# }

# # DA 1
# #
# record(ao, "$(SYSDEV)DAC1_SET")
# {
#     field(DESC, "Set Slew Rate Port0")
#     field(DTYP, "stream")
#     field( OUT, "@mps8500.proto setDA(1) $(HWUNIT)")
#     field(DRVL, "0")
#     field(DRVH, "255")
#     field(FLNK, "$(SYSDEV)DAC1_RB")
# }

# record(ai, "$(SYSDEV)DAC1_RB")
# {
#     field(DESC, "Read Slew Rate Port0")
#     field(DTYP, "stream")
#     field( INP, "@mps8500.proto getDA(1) $(HWUNIT)")
#     field(PINI, "YES")
#     field(FLNK, "$(SYSDEV)DAC1Update-RB_")
# }

# record(longout, "$(SYSDEV)DAC1Update-RB_")
# {
#     field( DOL, "$(SYSDEV)DAC1_RB NPP")
#     field(OMSL, "closed_loop")
#     field( OUT, "$(SYSDEV)DAC1_SET NPP")
# }

# # DA 2
# #
# record(ao, "$(SYSDEV)DAC2_SET")
# {
#     field(DESC, "Set Slew Rate Port1")
#     field(DTYP, "stream")
#     field( OUT, "@mps8500.proto setDA(2) $(HWUNIT)")
#     field(DRVL, "0")
#     field(DRVH, "255")
#     field(FLNK, "$(SYSDEV)DAC2_RB")
# }

# record(ai, "$(SYSDEV)DAC2_RB")
# {
#     field(DESC, "Read Slew Rate Port1")
#     field(DTYP, "stream")
#     field( INP, "@mps8500.proto getDA(2) $(HWUNIT)")
#     field(PINI, "YES")
#     field(FLNK, "$(SYSDEV)DAC2Update-RB_")
# }

# record(longout, "$(SYSDEV)DAC2Update-RB_")
# {
#     field( DOL, "$(SYSDEV)DAC2_RB NPP")
#     field(OMSL, "closed_loop")
#     field( OUT, "$(SYSDEV)DAC2_SET NPP")
# }


# # DA 3
# # Max value depends on the scaling factor.
# # Chaning the scaling factor, "Esc"<AD command will
# # be used.
# # But here I am using the fixed and default value
# # defined in P28 (R3)
# #
# record(ao, "$(SYSDEV)DAC3_SET")
# {
#     field(DESC, "Set Ramp Speed mA/s")
#     field(DTYP, "stream")
#     field( OUT, "@mps8500.proto setDA(3) $(HWUNIT)")
#     field(DRVL, "0")
#     field(DRVH, "1550.4")
#     field( EGU, "mA/s")
#     field(FLNK, "$(SYSDEV)DAC3_RB")
# }

# record(ai, "$(SYSDEV)DAC3_RB")
# {
#     field(DESC, "Read Ramp Speed mA/s")
#     field(DTYP, "stream")
#     field( INP, "@mps8500.proto getDA(3) $(HWUNIT)")
#     field(PINI, "YES")
#     field( EGU, "mA/s")
#     field(FLNK, "$(SYSDEV)DAC3Update-RB_")
# }

# record(longout, "$(SYSDEV)DAC3Update-RB_")
# {
#     field( DOL, "$(SYSDEV)DAC3_RB NPP")
#     field(OMSL, "closed_loop")
#     field( OUT, "$(SYSDEV)DAC3_SET NPP")
# }
